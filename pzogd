#!/usr/bin/python3

# ~/dev/py/pzog/pzogd

import os, sys, time
import socket
from argparse   import ArgumentParser

import serverutil
from pzog import *


# PATs AND REs ######################################################

def doWhatever(args):
    verbose = args.verbose

    s = None
    (cnx, addr) = (None, None)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(('', args.port))
    s.listen(1)
    try:
        running = True
        while running:
            print("WAITING FOR CONNECTION")              # DEBUG
            cnx, addr = s.accept()
            try:
                acceptMsg = "CONNECTION FROM %s" % str(addr)
                if verbose:                     print(acceptMsg)
                print("BRANCH TO args.accessLog.log()")  ; sys.stdout.flush()
                args.accessLog.log(acceptMsg)
                print("BACK FROM args.access.log()")  ; sys.stdout.flush()
        
                while 1:
                    print("BRANCH TO cnx.recv")  ; sys.stdout.flush()
                    data = cnx.recv(PZOG_MAX_MSG)
                    # DEBUG
                    print("RECEIVED: %s" % data)         # DEBUG
                    # END
                    if not data:                
                        break
                    if data.endswith('\r\n'):
                        cnx.sendall('ok\r\n')
                        args.accessLog.log( data[:-2] )
                        if data == 'quit\r\n':  
                            break
                        if data == 'shutdown\r\n':
                            running = False
                            break
                    else:
                        errMsg = '%s: %s' % (addr, data)
                        # XXX should log to error.log
                        break # --+
            except KeyboardInterrupt as ke:
                print("<keyboard interrupt received while connection open>")
                # connection will be closed
            finally:#<------------+
                if cnx:
                    cnx.close()
    except KeyboardInterrupt as ke:
        print("<keyboard interrupt received while listening>")
        # listening socket will be closed
    finally:
        if cnx: 
            cnx.close() 
        if s: 
            s.close()
 
def main():

    pgmNameAndVersion   = "pzogd v%s %s" % ( __version__, __version_date__)
    timestamp           = "%04d%02d%02d-%02d%02d%02d" % time.gmtime()[:6]

    # -- program defaults -------------------------------------------

    with open('/etc/hostname', 'r') as f:
        thisHost = f.read().strip()
    # DEBUG
    print("thisHost is '%s'" % thisHost)
    # END
    
    # -- check for config file --------------------------------------

    # -- parse the command line -------------------------------------
    # see docs.python.org/library/argparse.html 
    parser = ArgumentParser()
    
    parser.add_argument('-e', '--ec2Host',      action='store_true', 
            help='set if machine is in EC2')

    parser.add_argument('-j', '--justShow', action='store_true',
            help='show args and exit')
    parser.add_argument('-p', '--port', type=int, default=PZOG_PORT,
            help='port to listen on')
    parser.add_argument('-t', '--showTimestamp', action='store_true',
            help='show run timestamp')

    parser.add_argument('-T', '--testing', action='store_true',
            help='test run - write to ./testU')

    parser.add_argument('-V', '--showVersion', action='store_true',
            help='show version number and date')

    parser.add_argument('-v', '--verbose', action='store_true',
            help='talk a lot')

    args = parser.parse_args()      # a Namespace object

    # -- fixups -----------------------------------------------------
    args.pgmNameAndVersion = pgmNameAndVersion
    args.timestamp      = timestamp

    # -- sanity checks ----------------------------------------------
    if args.port <= 0 or 65536 <= args.port:
        print("port '%d' is out of range" % args.port)
        sys.exit(1)

    # XXX logs/ must be a directory; {access,error}.log must be files
    logDir = 'logs'
    if not os.path.exists(logDir):
        os.mkdir(logDir)
    args.logDir =logDir

    # fixups --------------------------------------------------------
    args.pgmNameAndVersion  = pgmNameAndVersion
    args.thisHost           = thisHost

    # -- do it ------------------------------------------------------
    if args.verbose or args.showVersion or args.justShow:
        print(args.pgmNameAndVersion)
    if args.showTimestamp:
        print('run at %s GMT' % timestamp)   # could be prettier
    else:
        print()                               # there's a comma up there

    if args.justShow or args.verbose:
        print('justShow         = ' + str(args.justShow))
        print('logDir           = ' + str(args.logDir))
        print('port             = ' + str(args.port))
        print('showTimestamp    = ' + str(args.showTimestamp))
        print('showVersion      = ' + str(args.showVersion))
        print('testing          = ' + str(args.testing))
        print('timestamp        = ' + str(args.timestamp))
        print('verbose          = ' + str(args.verbose))
        
    if not args.justShow:
        lockMgr     = None
        accessLog   = None
        errorLog    = None
        try:
            lockMgr         = serverutil.LockMgr('pzog')
            logMgr          = serverutil.LogMgr(args.logDir)
            accessLog       = logMgr.open('access')
            args.accessLog  = accessLog
#           # DEBUG -------------------------------------------------
#           print "ACCESS LOG IS %s" % accessLog.logFileName
#           # write to the log file causes core dump XXXXX
#           accessLog.log("opened access log")
#           # END ---------------------------------------------------
            errorLog        = logMgr.open('error')
            args.errorLog   = errorLog
            # DEBUG -------------------------------------------------
            print("SERVERUTIL VERSION IS %s" % serverutil.__version__)
            print("ERROR LOG IS %s" % errorLog.logFileName)
            # write to the log file causes core dump XXXXX
            errorLog.log("opened error log")
            # END ---------------------------------------------------
            doWhatever(args)
        finally:
            # XXX better: put each of these in a try block, swallowing
            #   exceptions
            if logMgr:      logMgr.close()
            if lockMgr:     lockMgr.unlock()

if __name__ == '__main__':
    main()
